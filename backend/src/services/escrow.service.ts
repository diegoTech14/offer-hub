import { Address as SorobanAddress } from "@stellar/stellar-sdk";
import { InternalServerError } from "@/utils/AppError";
import { randomBytes, createHash } from "crypto";
import { getStellarClientFactory } from "@/services/stellar";
import { getContractAddress } from "@/config/stellar-contracts";

/**
 * Escrow Service
 * Handles interaction with the Stellar escrow-factory contract using typed bindings
 */
export class EscrowService {
  private feeManagerAddress: string;

  constructor() {
    // Load fee manager address from configuration
    this.feeManagerAddress = getContractAddress("feeManager");
    
    if (!this.feeManagerAddress) {
      throw new Error("FEE_MANAGER_CONTRACT_ID is required in environment variables");
    }
  }

  /**
   * Converts a Stellar address string to a Soroban Address type
   */
  private addressToSorobanAddress(address: string): SorobanAddress {
    try {
      return SorobanAddress.fromString(address);
    } catch (error) {
      throw new InternalServerError(
        `Invalid Stellar address format: ${address}`,
        { originalError: error instanceof Error ? error.message : String(error) }
      );
    }
  }

  /**
   * Generates a unique salt for escrow deployment
   * Salt is generated by hashing: projectId + timestamp + random bytes
   * Returns Uint8Array of 32 bytes (BytesN<32>) for Soroban contract
   * The SDK will automatically convert this to BytesN<32> when invoking the contract
   */
  private generateSalt(projectId: string): Uint8Array {
    const timestamp = Date.now().toString();
    const random = randomBytes(16);
    const combined = `${projectId}_${timestamp}_${random.toString("hex")}`;
    const hash = createHash("sha256").update(combined).digest();
    
    // Return first 32 bytes as Uint8Array
    // The SDK's client.methods will convert this to BytesN<32> automatically
    return new Uint8Array(hash.slice(0, 32));
  }

  /**
   * Converts amount from XLM to stroops (i128 format)
   * 1 XLM = 10,000,000 stroops
   */
  private amountToStroops(amount: number): bigint {
    return BigInt(Math.floor(amount * 10_000_000));
  }

  /**
   * Creates a new escrow contract via the escrow-factory
   * 
   * @param params - Escrow creation parameters
   * @returns The deployed escrow contract address
   * @throws InternalServerError if escrow creation fails
   */
  async createEscrow(params: {
    clientAddress: string;
    freelancerAddress: string;
    amount: number; // Amount in XLM
    projectId: string; // For salt generation
  }): Promise<string> {
    try {
      // Get the typed escrow factory client from the factory
      const clientFactory = getStellarClientFactory();
      const escrowFactoryClient = await clientFactory.getEscrowFactory();

      // Convert addresses to Soroban Address types
      const clientAddr = this.addressToSorobanAddress(params.clientAddress);
      const freelancerAddr = this.addressToSorobanAddress(params.freelancerAddress);
      const feeManagerAddr = this.addressToSorobanAddress(this.feeManagerAddress);

      // Convert amount to stroops
      const amountStroops = this.amountToStroops(params.amount);

      // Generate unique salt
      const saltBytes = this.generateSalt(params.projectId);

      // Prepare EscrowCreateParams struct
      // The contract expects a struct with: client, freelancer, amount, fee_manager, salt
      const escrowParams = {
        client: clientAddr,
        freelancer: freelancerAddr,
        amount: amountStroops, // i128 as bigint
        fee_manager: feeManagerAddr,
        salt: saltBytes, // BytesN<32>
      };

      // Invoke deploy_new_escrow method using the typed client
      // This provides IntelliSense and compile-time type checking
      const result = await escrowFactoryClient.deployNewEscrow(escrowParams);

      // Extract the escrow contract address from the result
      if (!result.result) {
        throw new InternalServerError("Escrow deployment returned no address");
      }

      // The return value is a SorobanAddress, convert to string
      let escrowAddress: string;
      if (result.result instanceof SorobanAddress) {
        escrowAddress = result.result.toString();
      } else {
        // Fallback: try to extract address from the result
        escrowAddress = String(result.result);
      }
      
      return escrowAddress;
    } catch (error) {
      // Handle Stellar-specific errors and convert to AppError
      if (error instanceof Error) {
        throw new InternalServerError(
          `Failed to create escrow: ${error.message}`,
          { 
            originalError: error.message,
            stack: error.stack,
            params: {
              clientAddress: params.clientAddress,
              freelancerAddress: params.freelancerAddress,
              amount: params.amount,
            }
          }
        );
      }
      throw new InternalServerError(
        "Failed to create escrow: Unknown error",
        { originalError: String(error) }
      );
    }
  }
}

// Export singleton instance
export const escrowService = new EscrowService();
