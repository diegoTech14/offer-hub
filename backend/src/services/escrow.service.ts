import { 
  Keypair, 
  Networks, 
  Address as SorobanAddress,
} from "@stellar/stellar-sdk";
// @ts-ignore - Client is exported from /contract subpath but TypeScript resolution has issues
import { Client } from "@stellar/stellar-sdk/contract";
import { InternalServerError } from "@/utils/AppError";
import { randomBytes, createHash } from "crypto";

/**
 * Escrow Service
 * Handles interaction with the Soroban escrow-factory contract
 */
export class EscrowService {
  private escrowFactoryAddress: string;
  private feeManagerAddress: string;
  private networkPassphrase: string;
  private rpcUrl: string;
  private signerKeypair: Keypair;

  constructor() {
    // Load configuration from environment variables
    this.escrowFactoryAddress = process.env.ESCROW_FACTORY_CONTRACT_ADDRESS || "";
    this.feeManagerAddress = process.env.FEE_MANAGER_CONTRACT_ADDRESS || "";
    const network = (process.env.SOROBAN_NETWORK || "testnet").toLowerCase();
    
    // Set network passphrase
    if (process.env.SOROBAN_NETWORK_PASSPHRASE) {
      this.networkPassphrase = process.env.SOROBAN_NETWORK_PASSPHRASE;
    } else {
      this.networkPassphrase = network === "mainnet" 
        ? Networks.PUBLIC 
        : Networks.TESTNET;
    }

    // Set RPC URL
    if (process.env.SOROBAN_RPC_URL) {
      this.rpcUrl = process.env.SOROBAN_RPC_URL;
    } else {
      this.rpcUrl = network === "mainnet"
        ? "https://soroban-rpc.mainnet.stellar.org"
        : "https://soroban-testnet.stellar.org";
    }

    // Load signer keypair
    const signerSecretKey = process.env.ESCROW_SIGNER_SECRET_KEY;
    if (!signerSecretKey) {
      throw new Error("ESCROW_SIGNER_SECRET_KEY is required in environment variables");
    }
    this.signerKeypair = Keypair.fromSecret(signerSecretKey);

    // Validate required configuration
    if (!this.escrowFactoryAddress) {
      throw new Error("ESCROW_FACTORY_CONTRACT_ADDRESS is required in environment variables");
    }
    if (!this.feeManagerAddress) {
      throw new Error("FEE_MANAGER_CONTRACT_ADDRESS is required in environment variables");
    }
  }

  /**
   * Converts a Stellar address string to a Soroban Address type
   */
  private addressToSorobanAddress(address: string): SorobanAddress {
    try {
      return SorobanAddress.fromString(address);
    } catch (error) {
      throw new InternalServerError(
        `Invalid Stellar address format: ${address}`,
        { originalError: error instanceof Error ? error.message : String(error) }
      );
    }
  }

  /**
   * Generates a unique salt for escrow deployment
   * Salt is generated by hashing: projectId + timestamp + random bytes
   * Returns Uint8Array of 32 bytes (BytesN<32>) for Soroban contract
   * The SDK will automatically convert this to BytesN<32> when invoking the contract
   */
  private generateSalt(projectId: string): Uint8Array {
    const timestamp = Date.now().toString();
    const random = randomBytes(16);
    const combined = `${projectId}_${timestamp}_${random.toString("hex")}`;
    const hash = createHash("sha256").update(combined).digest();
    
    // Return first 32 bytes as Uint8Array
    // The SDK's client.methods will convert this to BytesN<32> automatically
    return new Uint8Array(hash.slice(0, 32));
  }

  /**
   * Converts amount from XLM to stroops (i128 format)
   * 1 XLM = 10,000,000 stroops
   */
  private amountToStroops(amount: number): bigint {
    return BigInt(Math.floor(amount * 10_000_000));
  }

  /**
   * Creates a new escrow contract via the escrow-factory
   * 
   * @param params - Escrow creation parameters
   * @returns The deployed escrow contract address
   * @throws InternalServerError if escrow creation fails
   */
  async createEscrow(params: {
    clientAddress: string;
    freelancerAddress: string;
    amount: number; // Amount in XLM
    projectId: string; // For salt generation
  }): Promise<string> {
    try {
      // Convert addresses to Soroban Address types
      const clientAddr = this.addressToSorobanAddress(params.clientAddress);
      const freelancerAddr = this.addressToSorobanAddress(params.freelancerAddress);
      const feeManagerAddr = this.addressToSorobanAddress(this.feeManagerAddress);

      // Convert amount to stroops
      const amountStroops = this.amountToStroops(params.amount);

      // Generate unique salt
      const saltBytes = this.generateSalt(params.projectId);

      // Initialize Soroban client for escrow-factory contract
      const client = await Client.from({
        contractId: this.escrowFactoryAddress,
        networkPassphrase: this.networkPassphrase,
        rpcUrl: this.rpcUrl,
        publicKey: this.signerKeypair.publicKey(),
        signTransaction: async (tx: any) => {
          // Sign the transaction with the signer keypair
          tx.sign(this.signerKeypair);
          return tx;
        },
      });

      // Prepare EscrowCreateParams struct
      // The contract expects a struct with: client, freelancer, amount, fee_manager, salt
      // The SDK's client.methods API automatically handles struct serialization
      const escrowParams = {
        client: clientAddr,
        freelancer: freelancerAddr,
        amount: amountStroops, // i128 as bigint
        fee_manager: feeManagerAddr,
        salt: saltBytes, // BytesN<32>
      };

      // Invoke deploy_new_escrow method
      // The SDK will automatically serialize the struct parameter
      const invokeTx = await client.methods.deploy_new_escrow(escrowParams);
      
      // Sign and send the transaction
      const result = await invokeTx.signAndSend();

      // Extract the escrow contract address from the result
      // The method returns an Address (SorobanAddress)
      if (!result.returnValue) {
        throw new InternalServerError("Escrow deployment returned no address");
      }

      // The return value is a SorobanAddress, convert to string
      let escrowAddress: string;
      if (result.returnValue instanceof SorobanAddress) {
        escrowAddress = result.returnValue.toString();
      } else {
        // Fallback: try to extract address from ScVal if needed
        escrowAddress = String(result.returnValue);
      }
      
      return escrowAddress;
    } catch (error) {
      // Handle Soroban-specific errors and convert to AppError
      if (error instanceof Error) {
        throw new InternalServerError(
          `Failed to create escrow: ${error.message}`,
          { 
            originalError: error.message,
            stack: error.stack,
            params: {
              clientAddress: params.clientAddress,
              freelancerAddress: params.freelancerAddress,
              amount: params.amount,
            }
          }
        );
      }
      throw new InternalServerError(
        "Failed to create escrow: Unknown error",
        { originalError: String(error) }
      );
    }
  }
}

// Export singleton instance
export const escrowService = new EscrowService();
